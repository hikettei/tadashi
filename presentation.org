#+startup: beamer
#+title: Polyhedral Tutor
#+options: h:2 ':t
#+latex_header: \usepackage[]{lmodern}
#+latex_header: \usepackage[T1]{fontenc}
#+beamer_theme: Montpellier
#+beamer_color_theme: beaver
#+latex_class_options: [serif,draft]
#+latex_header_extra: \usepackage{concrete}
#+beamer_header: \setbeamercolor{math text}{fg=black!15!magenta}
#+latex_header: \def\eg{e.g.\ }
#+latex_header: \def\ie{i.e.\ }

* Intro
** Polyhedral in practice and theory
*** In practice: Make code faster
    advanced loop transformations
    - Loop permutation, vectorisation, fusion, tiling, strip-minig
*** In theory: describe and reason about loops
    to describe:
    - Sets and relations of named integer tuples, Presburger formulas,
      piece\-wise quasi-affine maps
    to reason:
    - Math/ILP $\implies$ calculus on Presburger formulas
** The process
*** Source to Source compilation (simplified)
    1. *Input*: source code ("nice" loops, ~#pragma scop~ or
       auto-detect)
    2. Problem 1: Find "nice" loops: PET *extracts* ISL named tuple
       sets/relations (and a trivial schedule)
    3. Problem 2: Find the *true dependencies*
    4. *PROBLEM 3*: Find a (transform the trivial schedule) to a
       better *(optimal) schedule* (using ILP)
    5. Problem 4: Based on the optimal schedule (and domain) *generate
       ~C~ code*
    6. *Output*: transformed loop (new ~.c~ file)

** Statements vs statement instances
   #+begin_src fortran
           do i = 0,n
      1       y(i) = 0.
              do j = 0,n
      2          y(i) = y(i) + a(i,j)*x(j)
              end do
           end do
   #+end_src
   - Every command (in the source code) which reads/writes the memory
     is a *statement*, \eg ~1: y(i) = 0~
   - Each statement has multiple *instances*:
     - ~y(0)=0~ for ~i=0~, ~y(1)=0~ for ~i=1~ etc.
   - $n$ is a *parameter*, treated as a constant, can be ignored
   - The set of instances of "nice" loops have affine description:
     - $n \mapsto \{ s_1 : 1 \le 0 \le n \}$, $n \mapsto \{ s_2 : 1
       \le i, j \le n \}$
** Literature
*** Problem 3
    - This is the central idea of polyhedral compilation
    - Other problems are also important (maybe more important, \eg
      dependency analysis)
    - Described by: Some Efficient Solutions to the Affine Scheduling
      Problem. I. One-Dimensional Time -- Paul Feautrier
* Discussion of the paper
** Dependence graph
*** Generalised Dependence Graph (GDG)
    - *Vertex*: $\forall$ statement $S$ is the *polyhedron*
      $\mathfrak{D}_S \subset \mathbb{Q}^{P_S}$, $P_S \in \mathbb{N}$
      is the dimension of the iteration space, \ie the number of loops
      enclosing $S$. Every instance of every statement can be
      described by $(S, x)$ for $x \in \mathfrak{D}_S$.
    - *Edge*: $\forall$ edge $e$ from (statement) $R$ to (statement)
      $S$ is the *polyhedron* $\mathfrak{R}_e \subset \mathbb{Q}^{P_R + P_S}$
*** Detailed Dependence Graph (DDG)
    Vertices: $\Omega = \cup_{S \in V} \{ (S, x) : x \in
    \mathfrak{D}_S \}$

    Edges: $$\Gamma = \cup_{e \in E} \{ \langle (\sigma(e), x),
    (\delta(e), y) \rangle : x \in \mathfrak{D}_{\sigma(e)}, y \in
    \mathfrak{D}_{\delta(e)}, \langle x, y \rangle \in \mathfrak{R}_e
    \}$$
** Vertex polyhedron example
   #+begin_src fortran
           do i = 0,n
      1       y(i) = 0.
              do j = 0,n
      2          y(i) = y(i) + a(i,j)*x(j)
              end do
           end do
   #+end_src
   - $\mathfrak{D}_1 = \{ i : 0 \le i \le n \}$
   - $\mathfrak{D}_2 = \{ i, j : 0 \le i, j \le n \}$
   - $\langle i', i, j \rangle \in \mathfrak{R}_{1,2} \iff i' = i$
   - $\langle i', j', i, j \rangle \in \mathfrak{R}_{2,2} \iff i' = i
     \land j' < j$
** Schedule
*** The map from statements instances to dates
    - A *schedule* describes when an instance of a statement will be
      described: $\theta(S, x) = t$ is the /date/ of the instance.
    - Trivial schedule: $u, v \in \Omega, u \Gamma v \implies
      \theta(u) + 1 \ge \theta(v)$
*** Simplified "code generation"
    Let $\mathfrak{F}(t) = \{ u \in \Omega : \theta(u) = t \}$ and $L =
    \max_{u \in \Omega} \theta(u)$.
    - ~do~ $t = 0, L$
      - ~doall~ $\mathfrak{F}(t)$
      - ~barrier~
    - ~end do~
** Impossibility theorems, Proposed solution
*** Impossibility theorems
    - The consistency problem for a nonuniform GDG with at least one
      infinite domain is undecidable.
    - The consistency problem for an infinite family of nonuniform GDG
      with finite domains is undecidable.
*** Proposed solution
    Look for an affine schedule only:
    $$\theta(S, x) = \tau_S x + \sigma_S n + \alpha_S$$
    - Note: we can drop the integer constraints
** First steps towards parallel programs
*** Depth etc.
    - *Depth* of edge $e$: $p_e \in \mathbb{N}$ such that $\langle x,
      y \rangle \in \mathfrak{R}_e \iff x[1 \ldots p_e] = y[1 \ldots
      p_e] \land x[p_e + 1] < y[p_e + 1]$
    - *Dependence direction vectors* (DDV): $\langle \overbrace{=,
      \cdots, =}^{p_e}, <, *, \cdots \rangle$
    - If $y = x + d$ the dependency is *uniform* resulting in a
      *dependency cone*.
    - Reduce $\mathfrak{R}_e$ to a minimal form: polyhedron
      $\mathfrak{P}_e$ and an affine transformation $h_e$ such that:
      - $\langle x, y \rangle \in \mathfrak{R}_e \iff (x = h_e(y)
        \land y \in \mathfrak{P}_e$
      - then $y \in \mathfrak{P}_e \implies y \in \mathfrak{D}_{\delta(e)}
        \land h_e(y) \in \mathfrak{D}_{\sigma(e)}$
** Farkas algorithm
   #+begin_export latex
     \begin{gather}
     \label{eq:farkas1}
     \theta(S, x) \equiv \mu_{S_0} + \sum_{k=1}^{m_S} \mu_{S_k}
     \Bigl( a_{S_k} \begin{pmatrix} x \\ n \end{pmatrix} + b_{S_k} \Bigr)\\
     \label{eq:farkas2}
     \theta(\delta(e), y) - \theta(\sigma(e), x) - 1 \equiv \lambda_{e_0} + \sum_{k=1}^{m_e} \lambda_{e_k}
     \Bigl( c_{e_k} \begin{pmatrix} x \\ y \\ n \end{pmatrix} + d_{e_k} \Bigr)\\
     \label{eq:farkase}
     \theta(\delta(e), y) - \theta(\sigma(e), h_e(y)) - 1 \equiv \lambda_{e_0} + \sum_{k=1}^{m_e} \lambda_{e_k}
     \Bigl( c_{e_k} \begin{pmatrix} x \\ n \end{pmatrix} + d_{e_k} \Bigr)
     \end{gather}
   #+end_export
