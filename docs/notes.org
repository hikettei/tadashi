* More efficient legality check
SCH: [N] -> L_0[{ S_0[i, j] -> [(i - (i) mod 4)] }]
SCH: [N] -> { S_0[i, j] -> L_0[o0] : (i) mod 4 = i - o0 and -3 + i <= o0 <= i }
apply
DEP: [N] -> { S_0[i, j] -> S_0[i' = 1 + i, j' = j] : 0 < i <= -2 + N and 0 <= j < N }
=============
RES: [N] -> { L_0[i0] -> L_0[o0] :
  N >= 3 and
  (i0) mod 4 = 0 and
  -2 <= i0 < N - 1 and   # i0 = 0, 4, 8 but N = 9 so WTF????
  i0 < o0 + 1 and
  -1 <= o0 <= 4 + i0 and
  (o0) mod 4 = 0 and
  o0 < N }


- i L_0 is c0
- 
| i - 3 | i - (i mod 4) |  i | i mod 4 |
|     5 |             8 |  8 |       0 |
|     6 |             8 |  9 |       1 |
|     7 |             8 | 10 |       2 |
|     8 |             8 | 11 |       3 |
|       |            12 | 12 |       0 |
|       |            12 | 13 |       1 |

* pet_loopback callback
** id2stmt = set_up_id2stmt
#+begin_src C
  /* Set up a mapping from statement names to the corresponding statements.
   * Each statement is attached as a user pointer to an identifier
   * with the same name as the statement.
   */

  static __isl_give isl_id_to_id *set_up_id2stmt(struct pet_scop *scop) {
    int i;
    isl_ctx *ctx;
    isl_id_to_id *id2stmt;

    ctx = isl_set_get_ctx(scop->context);
    id2stmt = isl_id_to_id_alloc(ctx, scop->n_stmt);

    for (i = 0; i < scop->n_stmt; ++i) {
      struct pet_stmt *stmt = scop->stmts[i];
      isl_id *tuple_id, *id;
      const char *name;

      tuple_id = isl_set_get_tuple_id(stmt->domain); // KEY(stmt->domain)
      name = isl_id_get_name(tuple_id);
      id = isl_id_alloc(ctx, name, stmt); // VALUE(name, stmt)
      id2stmt = isl_id_to_id_set(id2stmt, tuple_id, id);
    }

    return id2stmt;
  }
#+end_src

** build = isl_ast_build_set_at_each_domain(build, at_domain, id2stmt)
*** at_domain(node, build, id2stmt)
**** stmt = node_stmt(node, id2stmt)
#+begin_src C

  /* Return the pet_stmt corresponding to "node", assuming it is a user node
   * in an AST generated by isl_ast_build_node_from_schedule and
   * looking up such statements in "id2stmt".
   *
   * A user node in an AST generated by isl_ast_build_node_from_schedule
   * performs a call to the statement.  That is, the statement name
   * is the first argument of the associated call expression.
   *
   * Extract this statement name and then look it up in "id2stmt".
   */

  static struct pet_stmt *node_stmt(__isl_keep isl_ast_node *node,
                                    isl_id_to_id *id2stmt) {
    isl_ast_expr *expr, *arg;
    isl_id *id;
    struct pet_stmt *stmt;

    expr = isl_ast_node_user_get_expr(node);
    arg = isl_ast_expr_get_op_arg(expr, 0);
    isl_ast_expr_free(expr);
    id = isl_ast_expr_get_id(arg);
    isl_ast_expr_free(arg);

    id = isl_id_to_id_get(id2stmt, id);
    stmt = isl_id_get_user(id);
    isl_id_free(id);

    return stmt;
  }

#+end_src
***** Debug output
The ~id~ used in ~id2stmt~ is deeply packed into a node...
#+begin_example
+++ node: { user: { op: call, args: [ { id: S_0 } ] } }
>>> S_0();
+++ expr: { op: call, args: [ { id: S_0 } ] }
>>> S_0()
+++ arg: { id: S_0 }
>>> S_0
+++ id: S_0

#+end_example
**** shedule = isl_map_from_union_map(isl_ast_build_get_schedule(build))
**** reverse = isl_pw_multi_aff_from_map(isl_map_reverse(shedule))
**** ref2expr = pet_stmt_build_ast_exprs(stmt, build, fn_index=&pullback_index, user_index=reverse, fn_expr=NULL, user_expr=NULL)
***** pullback_index
#+begin_src C

  // pet_stmt_build_ast_exprs docs
  /* Construct an associative array
    ,*
    ,* from reference identifiers of access expressions in "stmt"
    ,*
    ,* to the corresponding isl_ast_expr.
    ,*
    ,* Each index expression is first transformed through "fn_index" (if
    ,* not NULL).
    ,*
    ,* Then an AST expression is generated using "build".
    ,*
    ,* Finally, the AST expression is transformed using "fn_expr" (if not
    ,* NULL).
   ,*/

  static __isl_give isl_multi_pw_aff *
  pullback_index(__isl_take isl_multi_pw_aff *index, //
                 __isl_keep isl_id *ref_id, //
                 void *user) {
    isl_pw_multi_aff *fn = user;
    fn = isl_pw_multi_aff_copy(fn);
    return isl_multi_pw_aff_pullback_pw_multi_aff(index, fn);
  }

#+end_src
**** id = isl_id_alloc(ctx=isl_ast_node_get_ctx(node), NULL, ref2expr)
**** id = isl_id_set_free_user(id, &free_isl_id_to_ast_expr)
#+begin_src C
static void free_isl_id_to_ast_expr(void *user) {
  isl_id_to_ast_expr *id_to_ast_expr = user;

  isl_id_to_ast_expr_free(id_to_ast_expr);
}
#+end_src
**** node = isl_ast_node_set_annotation(node, id);
**** return node;
** node = isl_ast_build_node_from_schedule(build, schedule)
** print_options = print_options_set_print_user(print_user, id2stmt)
** print_declarations(build, scop, &indent);
** print_macros(node);
** isl_ast_node_print(node, p, print_options);
** print_end_declarations(p, indent);

* Notes
- "leafs" are the schedule tree leafs, which are the statements in
  loops (e.g. S_0)
- ~id2stmt~ maps id (e.g. S_0) to the corresponding PET statement
  (e.g. ~A[i][j]=...~)
- ~at_domain()~ and ~print_user()~ are invoked for each "leaf"
