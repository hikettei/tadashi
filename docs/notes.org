* pet_loopback callback
** id2stmt = set_up_id2stmt
#+begin_src C
  /* Set up a mapping from statement names to the corresponding statements.
   * Each statement is attached as a user pointer to an identifier
   * with the same name as the statement.
   */

  static __isl_give isl_id_to_id *set_up_id2stmt(struct pet_scop *scop) {
    int i;
    isl_ctx *ctx;
    isl_id_to_id *id2stmt;

    ctx = isl_set_get_ctx(scop->context);
    id2stmt = isl_id_to_id_alloc(ctx, scop->n_stmt);

    for (i = 0; i < scop->n_stmt; ++i) {
      struct pet_stmt *stmt = scop->stmts[i];
      isl_id *tuple_id, *id;
      const char *name;

      tuple_id = isl_set_get_tuple_id(stmt->domain); // KEY(stmt->domain)
      name = isl_id_get_name(tuple_id);
      id = isl_id_alloc(ctx, name, stmt); // VALUE(name, stmt)
      id2stmt = isl_id_to_id_set(id2stmt, tuple_id, id);
    }

    return id2stmt;
  }
#+end_src

** build = isl_ast_build_set_at_each_domain(build, at_domain, id2stmt)
*** at_domain(node, build, id2stmt)
**** stmt = node_stmt(node, id2stmt)
#+begin_src C

  /* Return the pet_stmt corresponding to "node", assuming it is a user node
   * in an AST generated by isl_ast_build_node_from_schedule and
   * looking up such statements in "id2stmt".
   *
   * A user node in an AST generated by isl_ast_build_node_from_schedule
   * performs a call to the statement.  That is, the statement name
   * is the first argument of the associated call expression.
   *
   * Extract this statement name and then look it up in "id2stmt".
   */

  static struct pet_stmt *node_stmt(__isl_keep isl_ast_node *node,
                                    isl_id_to_id *id2stmt) {
    isl_ast_expr *expr, *arg;
    isl_id *id;
    struct pet_stmt *stmt;

    expr = isl_ast_node_user_get_expr(node);
    arg = isl_ast_expr_get_op_arg(expr, 0);
    isl_ast_expr_free(expr);
    id = isl_ast_expr_get_id(arg);
    isl_ast_expr_free(arg);

    id = isl_id_to_id_get(id2stmt, id);
    stmt = isl_id_get_user(id);
    isl_id_free(id);

    return stmt;
  }

#+end_src
***** Debug output
The ~id~ used in ~id2stmt~ is deeply packed into a node...
#+begin_example
+++ node: { user: { op: call, args: [ { id: S_0 } ] } }
>>> S_0();
+++ expr: { op: call, args: [ { id: S_0 } ] }
>>> S_0()
+++ arg: { id: S_0 }
>>> S_0
+++ id: S_0

#+end_example
**** shedule = isl_map_from_union_map(isl_ast_build_get_schedule(build))
**** reverse = isl_pw_multi_aff_from_map(isl_map_reverse(shedule))
**** ref2expr = pet_stmt_build_ast_exprs(stmt, build, fn_index=&pullback_index, user_index=reverse, fn_expr=NULL, user_expr=NULL)
***** pullback_index
#+begin_src C

    /* Construct an associative array from reference identifiers of
     * access expressions in "stmt" to the corresponding isl_ast_expr.
     * Each index expression is first transformed through "fn_index"
     * (if not NULL).  Then an AST expression is generated using "build".
     * Finally, the AST expression is transformed using "fn_expr"
     * (if not NULL).
     */

    static __isl_give isl_multi_pw_aff *
    pullback_index(__isl_take isl_multi_pw_aff *index, //
                   __isl_keep isl_id *ref_id, //
                   void *user) {
      isl_pw_multi_aff *fn = user;
      fn = isl_pw_multi_aff_copy(fn);
      return isl_multi_pw_aff_pullback_pw_multi_aff(index, fn);
    }

#+end_src
**** id = isl_id_alloc(ctx=isl_ast_node_get_ctx(node), NULL, ref2expr)
**** id = isl_id_set_free_user(id, &free_isl_id_to_ast_expr)
#+begin_src C
static void free_isl_id_to_ast_expr(void *user) {
  isl_id_to_ast_expr *id_to_ast_expr = user;

  isl_id_to_ast_expr_free(id_to_ast_expr);
}
#+end_src
**** return node;
** node = isl_ast_build_node_from_schedule(build, schedule)
** print_options = print_options_set_print_user(print_user, id2stmt)
** print_declarations(build, scop, &indent);
** print_macros(node);
** isl_ast_node_print(node, p, print_options);
** print_end_declarations(p, indent);

